package com.groom.order.domain.entity;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;

import java.util.UUID;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

import com.groom.order.domain.status.OrderStatus;

/**
 * Order 엔티티 단위 테스트
 * 
 * 비즈니스 로직과 상태 전이 규칙을 검증합니다.
 * Mock 없이 순수 도메인 로직만 테스트합니다.
 */
@DisplayName("Order 엔티티 테스트")
class OrderTest {

    private UUID buyerId;
    private String orderNumber;
    private Long totalPaymentAmount;
    private String recipientName;
    private String recipientPhone;
    private String zipCode;
    private String shippingAddress;
    private String shippingMemo;

    @BeforeEach
    void setUp() {
        buyerId = UUID.randomUUID();
        orderNumber = "20260204-123456";
        totalPaymentAmount = 50000L;
        recipientName = "홍길동";
        recipientPhone = "010-1234-5678";
        zipCode = "12345";
        shippingAddress = "서울시 강남구 테헤란로 123";
        shippingMemo = "문 앞에 놓아주세요";
    }

    @Nested
    @DisplayName("주문 생성 테스트")
    class CreateOrderTest {

        @Test
        @DisplayName("주문 생성 시 초기 상태는 PENDING이어야 한다")
        void createOrder_InitialStatus_ShouldBe_PENDING() {
            // given & when
            Order order = createDefaultOrder();

            // then
            assertThat(order.getStatus()).isEqualTo(OrderStatus.PENDING);
            assertThat(order.getOrderId()).isNotNull();
            assertThat(order.getBuyerId()).isEqualTo(buyerId);
            assertThat(order.getOrderNumber()).isEqualTo(orderNumber);
            assertThat(order.getTotalPaymentAmount()).isEqualTo(totalPaymentAmount);
            assertThat(order.getRecipientName()).isEqualTo(recipientName);
            assertThat(order.getRecipientPhone()).isEqualTo(recipientPhone);
            assertThat(order.getZipCode()).isEqualTo(zipCode);
            assertThat(order.getShippingAddress()).isEqualTo(shippingAddress);
            assertThat(order.getShippingMemo()).isEqualTo(shippingMemo);
        }

        @Test
        @DisplayName("주문 생성 시 orderId는 자동으로 생성되어야 한다")
        void createOrder_OrderId_ShouldBe_AutoGenerated() {
            // given & when
            Order order1 = createDefaultOrder();
            Order order2 = createDefaultOrder();

            // then
            assertThat(order1.getOrderId()).isNotNull();
            assertThat(order2.getOrderId()).isNotNull();
            assertThat(order1.getOrderId()).isNotEqualTo(order2.getOrderId());
        }

        @Test
        @DisplayName("주문 생성 시 items 컬렉션은 초기화되어야 한다")
        void createOrder_Items_ShouldBe_Initialized() {
            // given & when
            Order order = createDefaultOrder();

            // then
            assertThat(order.getItems()).isNotNull();
            assertThat(order.getItems()).isEmpty();
        }
    }

    @Nested
    @DisplayName("결제 확인 테스트 (confirmPayment)")
    class ConfirmPaymentTest {

        @Test
        @DisplayName("PENDING 상태에서 결제 확인 시 PAID로 전이되어야 한다")
        void confirmPayment_FromPending_ShouldTransitionTo_PAID() {
            // given
            Order order = createDefaultOrder();
            assertThat(order.getStatus()).isEqualTo(OrderStatus.PENDING);

            // when
            order.confirmPayment();

            // then
            assertThat(order.getStatus()).isEqualTo(OrderStatus.PAID);
        }

        @Test
        @DisplayName("PAID 상태에서 결제 확인 시도 시 예외가 발생해야 한다")
        void confirmPayment_FromPaid_ShouldThrowException() {
            // given
            Order order = createDefaultOrder();
            order.confirmPayment(); // PENDING -> PAID

            // when & then
            assertThatThrownBy(() -> order.confirmPayment())
                    .isInstanceOf(IllegalStateException.class)
                    .hasMessageContaining("결제 확인은 PENDING 상태에서만 가능합니다");
        }

        @Test
        @DisplayName("CONFIRMED 상태에서 결제 확인 시도 시 예외가 발생해야 한다")
        void confirmPayment_FromConfirmed_ShouldThrowException() {
            // given
            Order order = createDefaultOrder();
            order.confirmPayment(); // PENDING -> PAID
            order.complete(); // PAID -> CONFIRMED

            // when & then
            assertThatThrownBy(() -> order.confirmPayment())
                    .isInstanceOf(IllegalStateException.class)
                    .hasMessageContaining("결제 확인은 PENDING 상태에서만 가능합니다");
        }

        @Test
        @DisplayName("FAILED 상태에서 결제 확인 시도 시 예외가 발생해야 한다")
        void confirmPayment_FromFailed_ShouldThrowException() {
            // given
            Order order = createDefaultOrder();
            order.fail(); // PENDING -> FAILED

            // when & then
            assertThatThrownBy(() -> order.confirmPayment())
                    .isInstanceOf(IllegalStateException.class)
                    .hasMessageContaining("결제 확인은 PENDING 상태에서만 가능합니다");
        }

        @Test
        @DisplayName("CANCELLED 상태에서 결제 확인 시도 시 예외가 발생해야 한다")
        void confirmPayment_FromCancelled_ShouldThrowException() {
            // given
            Order order = createDefaultOrder();
            order.cancel(); // PENDING -> CANCELLED

            // when & then
            assertThatThrownBy(() -> order.confirmPayment())
                    .isInstanceOf(IllegalStateException.class)
                    .hasMessageContaining("결제 확인은 PENDING 상태에서만 가능합니다");
        }
    }

    @Nested
    @DisplayName("주문 확정 테스트 (complete)")
    class CompleteOrderTest {

        @Test
        @DisplayName("PAID 상태에서 주문 확정 시 CONFIRMED로 전이되어야 한다")
        void complete_FromPaid_ShouldTransitionTo_CONFIRMED() {
            // given
            Order order = createDefaultOrder();
            order.confirmPayment(); // PENDING -> PAID
            assertThat(order.getStatus()).isEqualTo(OrderStatus.PAID);

            // when
            order.complete();

            // then
            assertThat(order.getStatus()).isEqualTo(OrderStatus.CONFIRMED);
        }

        @Test
        @DisplayName("PENDING 상태에서 주문 확정 시도 시 예외가 발생해야 한다")
        void complete_FromPending_ShouldThrowException() {
            // given
            Order order = createDefaultOrder();
            assertThat(order.getStatus()).isEqualTo(OrderStatus.PENDING);

            // when & then
            assertThatThrownBy(() -> order.complete())
                    .isInstanceOf(IllegalStateException.class)
                    .hasMessageContaining("주문 확정은 결제 완료(PAID) 이후에만 가능합니다");
        }

        @Test
        @DisplayName("CONFIRMED 상태에서 주문 확정 시도 시 예외가 발생해야 한다")
        void complete_FromConfirmed_ShouldThrowException() {
            // given
            Order order = createDefaultOrder();
            order.confirmPayment(); // PENDING -> PAID
            order.complete(); // PAID -> CONFIRMED

            // when & then
            assertThatThrownBy(() -> order.complete())
                    .isInstanceOf(IllegalStateException.class)
                    .hasMessageContaining("주문 확정은 결제 완료(PAID) 이후에만 가능합니다");
        }

        @Test
        @DisplayName("FAILED 상태에서 주문 확정 시도 시 예외가 발생해야 한다")
        void complete_FromFailed_ShouldThrowException() {
            // given
            Order order = createDefaultOrder();
            order.fail(); // PENDING -> FAILED

            // when & then
            assertThatThrownBy(() -> order.complete())
                    .isInstanceOf(IllegalStateException.class)
                    .hasMessageContaining("주문 확정은 결제 완료(PAID) 이후에만 가능합니다");
        }
    }

    @Nested
    @DisplayName("주문 실패 처리 테스트 (fail)")
    class FailOrderTest {

        @Test
        @DisplayName("PENDING 상태에서 실패 처리 시 FAILED로 전이되어야 한다")
        void fail_FromPending_ShouldTransitionTo_FAILED() {
            // given
            Order order = createDefaultOrder();
            assertThat(order.getStatus()).isEqualTo(OrderStatus.PENDING);

            // when
            order.fail();

            // then
            assertThat(order.getStatus()).isEqualTo(OrderStatus.FAILED);
        }

        @Test
        @DisplayName("PAID 상태에서 실패 처리 시 FAILED로 전이되어야 한다")
        void fail_FromPaid_ShouldTransitionTo_FAILED() {
            // given
            Order order = createDefaultOrder();
            order.confirmPayment(); // PENDING -> PAID

            // when
            order.fail();

            // then
            assertThat(order.getStatus()).isEqualTo(OrderStatus.FAILED);
        }

        @Test
        @DisplayName("CONFIRMED 상태에서 실패 처리 시도 시 예외가 발생해야 한다")
        void fail_FromConfirmed_ShouldThrowException() {
            // given
            Order order = createDefaultOrder();
            order.confirmPayment(); // PENDING -> PAID
            order.complete(); // PAID -> CONFIRMED

            // when & then
            assertThatThrownBy(() -> order.fail())
                    .isInstanceOf(IllegalStateException.class)
                    .hasMessageContaining("이미 완료되거나 취소된 주문은 실패 처리할 수 없습니다");
        }

        @Test
        @DisplayName("CANCELLED 상태에서 실패 처리 시도 시 예외가 발생해야 한다")
        void fail_FromCancelled_ShouldThrowException() {
            // given
            Order order = createDefaultOrder();
            order.cancel(); // PENDING -> CANCELLED

            // when & then
            assertThatThrownBy(() -> order.fail())
                    .isInstanceOf(IllegalStateException.class)
                    .hasMessageContaining("이미 완료되거나 취소된 주문은 실패 처리할 수 없습니다");
        }
    }

    @Nested
    @DisplayName("주문 취소 테스트 (cancel)")
    class CancelOrderTest {

        @Test
        @DisplayName("PENDING 상태에서 취소 시 CANCELLED로 전이되어야 한다")
        void cancel_FromPending_ShouldTransitionTo_CANCELLED() {
            // given
            Order order = createDefaultOrder();
            assertThat(order.getStatus()).isEqualTo(OrderStatus.PENDING);

            // when
            order.cancel();

            // then
            assertThat(order.getStatus()).isEqualTo(OrderStatus.CANCELLED);
        }

        @Test
        @DisplayName("PAID 상태에서 취소 시 CANCELLED로 전이되어야 한다")
        void cancel_FromPaid_ShouldTransitionTo_CANCELLED() {
            // given
            Order order = createDefaultOrder();
            order.confirmPayment(); // PENDING -> PAID

            // when
            order.cancel();

            // then
            assertThat(order.getStatus()).isEqualTo(OrderStatus.CANCELLED);
        }

        @Test
        @DisplayName("CONFIRMED 상태에서 취소 시 CANCELLED로 전이되어야 한다")
        void cancel_FromConfirmed_ShouldTransitionTo_CANCELLED() {
            // given
            Order order = createDefaultOrder();
            order.confirmPayment(); // PENDING -> PAID
            order.complete(); // PAID -> CONFIRMED

            // when
            order.cancel();

            // then
            assertThat(order.getStatus()).isEqualTo(OrderStatus.CANCELLED);
        }

        @Test
        @DisplayName("이미 CANCELLED 상태일 때 재취소 시도 시 멱등성이 보장되어야 한다")
        void cancel_FromCancelled_ShouldBe_Idempotent() {
            // given
            Order order = createDefaultOrder();
            order.cancel(); // PENDING -> CANCELLED
            assertThat(order.getStatus()).isEqualTo(OrderStatus.CANCELLED);

            // when
            order.cancel(); // 재취소 시도

            // then
            assertThat(order.getStatus()).isEqualTo(OrderStatus.CANCELLED); // 여전히 CANCELLED
            // 예외가 발생하지 않아야 함
        }

        @Test
        @DisplayName("FAILED 상태에서 취소 시도 시 예외가 발생해야 한다")
        void cancel_FromFailed_ShouldThrowException() {
            // given
            Order order = createDefaultOrder();
            order.fail(); // PENDING -> FAILED

            // when & then
            assertThatThrownBy(() -> order.cancel())
                    .isInstanceOf(IllegalStateException.class)
                    .hasMessageContaining("실패 또는 수동 확인 상태인 주문은 취소할 수 없습니다");
        }

        @Test
        @DisplayName("MANUAL_CHECK 상태에서 취소 시도 시 예외가 발생해야 한다")
        void cancel_FromManualCheck_ShouldThrowException() {
            // given
            Order order = createDefaultOrder();
            order.requireManualCheck(); // PENDING -> MANUAL_CHECK

            // when & then
            assertThatThrownBy(() -> order.cancel())
                    .isInstanceOf(IllegalStateException.class)
                    .hasMessageContaining("실패 또는 수동 확인 상태인 주문은 취소할 수 없습니다");
        }
    }

    @Nested
    @DisplayName("수동 확인 필요 테스트 (requireManualCheck)")
    class RequireManualCheckTest {

        @Test
        @DisplayName("PENDING 상태에서 수동 확인 필요 시 MANUAL_CHECK로 전이되어야 한다")
        void requireManualCheck_FromPending_ShouldTransitionTo_MANUAL_CHECK() {
            // given
            Order order = createDefaultOrder();
            assertThat(order.getStatus()).isEqualTo(OrderStatus.PENDING);

            // when
            order.requireManualCheck();

            // then
            assertThat(order.getStatus()).isEqualTo(OrderStatus.MANUAL_CHECK);
        }

        @Test
        @DisplayName("PAID 상태에서 수동 확인 필요 시 MANUAL_CHECK로 전이되어야 한다")
        void requireManualCheck_FromPaid_ShouldTransitionTo_MANUAL_CHECK() {
            // given
            Order order = createDefaultOrder();
            order.confirmPayment(); // PENDING -> PAID

            // when
            order.requireManualCheck();

            // then
            assertThat(order.getStatus()).isEqualTo(OrderStatus.MANUAL_CHECK);
        }

        @Test
        @DisplayName("FAILED 상태에서 수동 확인 필요 시 MANUAL_CHECK로 전이되어야 한다")
        void requireManualCheck_FromFailed_ShouldTransitionTo_MANUAL_CHECK() {
            // given
            Order order = createDefaultOrder();
            order.fail(); // PENDING -> FAILED

            // when
            order.requireManualCheck();

            // then
            assertThat(order.getStatus()).isEqualTo(OrderStatus.MANUAL_CHECK);
        }

        @Test
        @DisplayName("CONFIRMED 상태에서 수동 확인 필요 시도 시 예외가 발생해야 한다")
        void requireManualCheck_FromConfirmed_ShouldThrowException() {
            // given
            Order order = createDefaultOrder();
            order.confirmPayment(); // PENDING -> PAID
            order.complete(); // PAID -> CONFIRMED

            // when & then
            assertThatThrownBy(() -> order.requireManualCheck())
                    .isInstanceOf(IllegalStateException.class)
                    .hasMessageContaining("이미 완료되거나 취소된 주문은 수동 확인 상태로 변경할 수 없습니다");
        }

        @Test
        @DisplayName("CANCELLED 상태에서 수동 확인 필요 시도 시 예외가 발생해야 한다")
        void requireManualCheck_FromCancelled_ShouldThrowException() {
            // given
            Order order = createDefaultOrder();
            order.cancel(); // PENDING -> CANCELLED

            // when & then
            assertThatThrownBy(() -> order.requireManualCheck())
                    .isInstanceOf(IllegalStateException.class)
                    .hasMessageContaining("이미 완료되거나 취소된 주문은 수동 확인 상태로 변경할 수 없습니다");
        }
    }

    @Nested
    @DisplayName("OrderItem 추가 테스트")
    class AddItemTest {

        @Test
        @DisplayName("OrderItem을 추가할 수 있어야 한다")
        void addItem_ShouldAdd_OrderItem() {
            // given
            Order order = createDefaultOrder();
            OrderItem item1 = createOrderItem(order, "상품1", 10000L, 2);
            OrderItem item2 = createOrderItem(order, "상품2", 20000L, 1);

            // when
            order.addItem(item1);
            order.addItem(item2);

            // then
            assertThat(order.getItems()).hasSize(2);
            assertThat(order.getItems()).containsExactly(item1, item2);
        }

        @Test
        @DisplayName("빈 주문에 OrderItem이 없어야 한다")
        void emptyOrder_ShouldHave_NoItems() {
            // given
            Order order = createDefaultOrder();

            // when & then
            assertThat(order.getItems()).isEmpty();
        }
    }

    @Nested
    @DisplayName("상태 전이 시나리오 테스트")
    class StateTransitionScenarioTest {

        @Test
        @DisplayName("정상 주문 플로우: PENDING -> PAID -> CONFIRMED")
        void normalOrderFlow_ShouldTransition_Successfully() {
            // given
            Order order = createDefaultOrder();

            // when & then
            assertThat(order.getStatus()).isEqualTo(OrderStatus.PENDING);

            order.confirmPayment();
            assertThat(order.getStatus()).isEqualTo(OrderStatus.PAID);

            order.complete();
            assertThat(order.getStatus()).isEqualTo(OrderStatus.CONFIRMED);
        }

        @Test
        @DisplayName("결제 실패 플로우: PENDING -> FAILED")
        void paymentFailureFlow_ShouldTransition_Successfully() {
            // given
            Order order = createDefaultOrder();

            // when & then
            assertThat(order.getStatus()).isEqualTo(OrderStatus.PENDING);

            order.fail();
            assertThat(order.getStatus()).isEqualTo(OrderStatus.FAILED);
        }

        @Test
        @DisplayName("재고 차감 실패 플로우: PENDING -> PAID -> FAILED")
        void stockDeductionFailureFlow_ShouldTransition_Successfully() {
            // given
            Order order = createDefaultOrder();

            // when & then
            assertThat(order.getStatus()).isEqualTo(OrderStatus.PENDING);

            order.confirmPayment();
            assertThat(order.getStatus()).isEqualTo(OrderStatus.PAID);

            order.fail();
            assertThat(order.getStatus()).isEqualTo(OrderStatus.FAILED);
        }

        @Test
        @DisplayName("환불 성공 플로우: PENDING -> PAID -> CONFIRMED -> CANCELLED")
        void refundSuccessFlow_ShouldTransition_Successfully() {
            // given
            Order order = createDefaultOrder();

            // when & then
            assertThat(order.getStatus()).isEqualTo(OrderStatus.PENDING);

            order.confirmPayment();
            assertThat(order.getStatus()).isEqualTo(OrderStatus.PAID);

            order.complete();
            assertThat(order.getStatus()).isEqualTo(OrderStatus.CONFIRMED);

            order.cancel();
            assertThat(order.getStatus()).isEqualTo(OrderStatus.CANCELLED);
        }

        @Test
        @DisplayName("환불 실패 플로우: PENDING -> PAID -> MANUAL_CHECK")
        void refundFailureFlow_ShouldTransition_ToManualCheck() {
            // given
            Order order = createDefaultOrder();

            // when & then
            assertThat(order.getStatus()).isEqualTo(OrderStatus.PENDING);

            order.confirmPayment();
            assertThat(order.getStatus()).isEqualTo(OrderStatus.PAID);

            order.requireManualCheck();
            assertThat(order.getStatus()).isEqualTo(OrderStatus.MANUAL_CHECK);
        }

        @Test
        @DisplayName("사용자 취소 플로우: PENDING -> CANCELLED")
        void userCancellationFlow_ShouldTransition_Successfully() {
            // given
            Order order = createDefaultOrder();

            // when & then
            assertThat(order.getStatus()).isEqualTo(OrderStatus.PENDING);

            order.cancel();
            assertThat(order.getStatus()).isEqualTo(OrderStatus.CANCELLED);
        }
    }

    // ========== Helper Methods ==========

    private Order createDefaultOrder() {
        return Order.builder()
                .buyerId(buyerId)
                .orderNumber(orderNumber)
                .totalPaymentAmount(totalPaymentAmount)
                .recipientName(recipientName)
                .recipientPhone(recipientPhone)
                .zipCode(zipCode)
                .shippingAddress(shippingAddress)
                .shippingMemo(shippingMemo)
                .build();
    }

    private OrderItem createOrderItem(Order order, String productTitle, Long unitPrice, Integer quantity) {
        return OrderItem.builder()
                .order(order)
                .productId(UUID.randomUUID())
                .variantId(UUID.randomUUID())
                .ownerId(UUID.randomUUID())
                .productTitle(productTitle)
                .productThumbnail("https://example.com/thumbnail.jpg")
                .optionName("기본옵션")
                .unitPrice(unitPrice)
                .quantity(quantity)
                .build();
    }
}
